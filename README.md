# Head First设计模式

## 1. 设计模式入门——策略模式Strategy Pattern

### 设计原则

1. 找到应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起
2. 针对接口编程，而不是针对实现编程
   1. 针对超类型supertype进行编程，是一个抽象类或者一个接口
3. 多用组合少用继承——”有一个“（HAS-A）可能比”是一个“（IS-A）更好

### 策略模式

策略模式定义了算法族，分别封装起来，让它们之间可以互相替换，此模式**让算法的变化独立**于使用算法的客户。

### Tips

1. 封装的概念：原来在设计对象是会倾向于事物属性设为类变量，行为设为方法。然后行为如果很复杂，方法需要重复实现，完全也可以抽象成”对象“，即”万物皆对象“。
2. 请不要染上”模式病“，连写一个”Hello world“都能扯上模式



## 2.观察者（Observer）模式

可以理解为报纸订阅，出版者改称为”主题“（Subject），订阅者改称为”观察者“（Observer）

### 观察者模式

观察者模式定义了对象之间的**一对多依赖**，这样一来，当一个对象改变状态时，它的所有依赖着都会收到通知并自动更新。

### 设计原则

1. 为了交互对象之间的松耦合设计而努力

### 一些见解

1. [Stack Overflow-Java9后Observer被弃用](https://stackoverflow.com/questions/46380073/observer-is-deprecated-in-java-9-what-should-we-use-instead-of-it)



## 3.装饰者（Decorator）模式

### 装饰者模式

装饰器模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。

### 设计原则

1. 类应该对扩展开放，对修改关闭 

### 一些见解

1. 利用装饰者模式，常常造成设计中有大量的小类，数量实在太多



## 4.工厂（Factory）模式

### 工厂方法模式

工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

### 抽象工厂模式

抽象工厂模式提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

工厂方法模式潜伏在抽象工厂中。

### 设计原则

1. 依赖倒置原则（Dependency Inversion Principle）：要依赖抽象，不要依赖具体类
   1. 不让高层组件依赖低层组件，且不论高低层组件，两者都依赖于抽象
   2. 所谓高层组件是由其他低层组件定义其行为的类

### 一些见解

1. 一些流程固定，但是具体操作需要细分的情况，我们可以使用工厂模式
2. 简单工厂与工厂模式的区别：简单工厂将所有事情在一个地方都处理完了，而工厂模式却是创建了一个框架，让子类决定要如何实现。简单工厂不具备弹性



## 5.单件（Singleton）模式

### 单件模式

单件模式确保一个类只有一个实例，并提供一个全局访问点。

### 一些见解

1. 延迟实例化（lazy instantiaze）：如果我们不需要这个实例，它就永远不会产生



## 6.命令模式

### 命令模式

命令模式将“请求”封装成对象，以便使用不同的请求、队列或者日志来参数化其他对象，命令模式也支持可撤销的操作。

### 一些见解

1. 命令模式可以将“动作的请求者”从“动作的执行者”对象中解耦。
2. 使用NoCommand作为空对象，解决处理null



## 7.适配器(Adapter)模式与外观(Facade)模式

### 适配器模式

适配器模式将一个类的接口，转换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。

### 外观模式

外观模式提供了一个统一的接口，用来访问子系统中的一群接口。外观定义了一个高层接口，让子系统更容易使用。

### 设计原则

1. 最少知识原则：只和你的密友谈话。
   1. 避免调用从另一个调用中返回对象的方法

### 一些见解

1. 两种适配器
   1. 类适配器，使用多重继承，Java中不适用
   2. 对象适配器

2. 外观和适配器可以包装许多类，但是外观的意图是简化接口，而适配器的意图是将接口转换成不同接口。



## 8.模板方法模式

### 模板方法模式

模板方法模式在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。

### 设计原则

1. 好莱坞原则：别调用（打电话给）我们，我们会调用（打电话给）你。
   1. 高层组件可以调用低层组件，低层组件可以参与计算，但低层组件不能直接调用高层组件（避免高层与低层之间有明显的环状依赖）

### 一些见解

1. 钩子可以让子类实现算法中是可选的部分
2. 为了防止子类修改，可以将模板方法声明为final
3. 策略模式与模板方法模式都封装算法，一个用组合，一个用继承
4. 工厂方法是模板方法的一种特殊版本



## 9. 迭代器（Iterator）与组合模式

### 迭代器模式

迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露其内部的表示。

### 设计原则

1. 一个类应该只有一个引起变化的原因。
   1. 我们应该努力让一个类只分配一个责任

### 组合模式

组合模式允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。

透明性（transparency）：让组件的接口同时包含一些管理子节点和叶节点的操作，客户就可以将组合和叶节点一视同仁。

### 一些见解

1. 组合模式支持树形方式创建对象的结构
2. 抛出UnsupportedOperationException用于默认实现
3. 递归实现树形结构迭代器
4. 创建空迭代器（NullIterator），使得hasnext()始终返回false。用于树形结构中的叶子节点



## 10.状态模式

